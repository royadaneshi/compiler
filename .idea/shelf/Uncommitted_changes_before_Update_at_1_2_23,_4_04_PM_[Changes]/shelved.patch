Index: compiler.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import copy\nimport re\nimport json\nfrom treelib import Node, Tree\nfrom anytree import Node, RenderTree\n# Roya Daneshi 99101557 ,Pardis Zahraei 99109777\n\nclass Token:\n    Invalid = 'Invalid'\n    EndOfFile = 'EOF'\n    Number = 'NUM'\n    Identifier = 'ID'\n    Keyword = 'KEYWORD'\n    Symbol = 'SYMBOL'\n    Comment = 'COMMENT'\n    Whitespace = 'WHITESPACE'\n\n\nclass ErrorMsg:\n    Invalid_input = 'Invalid input'\n    Unclosed_comment = 'Unclosed comment'\n    Unmatched_comment = 'Unmatched comment'\n    Invalid_number = 'Invalid number'\n\n\nclass ParsErrorMsg:\n    # WATCH OUT:  these two massage here not in the documentation format!\n    Empty_parse_table = \"Empty_parse_table_home\"\n    Empty_parse_table_goto = \"Empty_parse_table_goto_home\"\n    # TODO complete error massages in panic mode here base on the documentation\n\n\"\"\"\nPARSER PART\n\"\"\"\nclass Parser:\n\n    def __init__(self):\n        self.follow = None\n        self.first = None\n        self.grammar = None\n        self.terminals = None\n        self.non_terminals = None\n        self.parse_table = None\n        self.read_json_file()\n        self.stack = None\n        self.input_tokens = None\n\n    def parser(self, cursor_line_position_scanner, program_input):  # DONE\n\n        self.stack = []\n        self.stack.append(\"$\")  # initialize stack at start state\n        self.stack.append(\"0\")\n        self.input_tokens = []\n        # self.input_tokens.append(\"$\")  # is it necessary?\n        while True:\n            first_token = get_next_token(cursor_line_position_scanner, program_input)\n            cursor_line_position_scanner = first_token[2]\n            if first_token[0] == \"$\":\n                self.input_tokens.append(first_token)\n                break  # end of file\n            if first_token[1] == \"\":\n                continue\n            else:\n                self.input_tokens.append(first_token)\n                break\n\n        while 1:\n            stack_state = self.stack[-1]  # get top of the stack\n            input_token = self.input_tokens[-1]  # get top of the input tokens\n            # check validation of input:\n            if input_token[1] in self.terminals or input_token[0] == \"ID\" or input_token[0] == \"NUM\" or input_token[\n                0] == \"$\":\n                state_columns_tuple = self.parse_table[stack_state]\n                if input_token[1] in state_columns_tuple.keys() or input_token[0] in state_columns_tuple.keys():\n                    if input_token[0] == \"ID\" or input_token[0] == \"NUM\" or input_token[0] == \"$\":\n                        table_content = self.parse_table[stack_state][input_token[0]]\n                    else:\n                        table_content = self.parse_table[stack_state][input_token[1]]\n                    if table_content.startswith(\"shift\"):\n                        shifted_token = self.input_tokens.pop()\n                        state_no = table_content.replace('shift_', '')\n                        self.stack.append(shifted_token)\n                        self.stack.append(state_no)\n                        # get nex token(call scanner):\n                        while True:\n                            current_token = get_next_token(cursor_line_position_scanner, program_input)\n                            cursor_line_position_scanner = current_token[2]\n                            if current_token[0] == \"$\":\n                                self.input_tokens.append(current_token)\n                                break  # end of file\n                            if current_token[1] == \"\":\n                                continue\n                            else:\n                                self.input_tokens.append(current_token)\n                                break\n\n                        continue\n                    elif table_content.startswith(\"reduce\"):\n                        rule_no = table_content.replace('reduce_', '')\n                        reduce_rule = self.grammar[rule_no]\n                        if reduce_rule[2] == \"epsilon\":  # if the rule goes to epsilon shouldn't pop anything from stack\n                            size_pop_stack = 0\n                            non_terminal_push = reduce_rule[0]\n                            reduced_elements=[\"epsilon\",1]\n                        else:\n                            size_pop_stack = 2 * (len(reduce_rule) - 2)\n                            non_terminal_push = reduce_rule[0]\n                            reduced_elements = self.stack[len(self.stack) - size_pop_stack:]\n\n                        self.stack = self.stack[:len(self.stack) - size_pop_stack]  # pop elements from the stack\n                        top_stack_no = self.stack[-1]  # get top of the stack state number\n                        non_terminal_goto = self.parse_table[top_stack_no]\n                        if non_terminal_push in non_terminal_goto:  # impossible error but I checked it!\n                            go_to = self.parse_table[top_stack_no][non_terminal_push]\n                            num_push = go_to.replace('goto_', '')\n                            self.stack.append(non_terminal_push)\n                            self.stack.append(num_push)\n                            parse_list.append([non_terminal_push, reduced_elements[::2]])\n\n                        else:\n                            self.syntax_errors(None, None,\n                                               ParsErrorMsg.Empty_parse_table_goto)  # empty home on goto table\n                        continue\n\n                    elif table_content.startswith(\"accept\"):\n                        # parse completed!\n                        self.parse_tree()\n                        print(\"parse completed!\")\n                        return 0  # say parse is finished\n\n                else:  # empty home in table\n                    self.syntax_errors(input_token, stack_state, ParsErrorMsg.Empty_parse_table)\n\n    def read_json_file(self):  # DONE  # this func called in init function at first.\n        f = open('table.json')\n        data = json.load(f)\n        self.terminals = data[\"terminals\"]\n        self.non_terminals = data[\"non_terminals\"]\n        self.first = data[\"first\"]\n        self.follow = data[\"follow\"]\n        self.grammar = data[\"grammar\"]\n        self.parse_table = data[\"parse_table\"]\n        f.close()\n\n    def parse_tree(self):\n        # TODO make the parse tree and write in a output file\n        \"\"\"\n        the given root to the function is not complete\n        for example A -> B -> C -> D\n        is needed to know where to put the link but only C -> D\n        is given and some other tokens as root are not sent here like A -> B  in example above\n        \"\"\"\n        # old code without treelib\n        \"\"\"\n        list_all_dfs=[]\n        print(parse_list)\n        new_parse_list=copy.deepcopy(parse_list)\n        top_elem = new_parse_list.pop()\n        parent_1 = top_elem[0]\n        child_1 = top_elem[1]\n        child_1_without_bracket = child_1[0]\n        if (len(child_1_without_bracket) == 3):\n            child_1.pop()\n        curent_list=[parent_1,child_1_without_bracket]\n        child_1_without_bracket_before =child_1_without_bracket\n        list_all_dfs.append(curent_list)\n        for i in range (len(new_parse_list)):\n            top_elem = new_parse_list.pop()\n            parent_1 = top_elem[0]\n            child_1 = top_elem[1]\n            child_1_without_bracket = list(child_1[0])\n            new_curent_list=copy.deepcopy(curent_list)\n            if (len(child_1_without_bracket) == 3):\n                child_1_without_bracket_before.pop()\n            if(parent_1==child_1_without_bracket_before):\n                new_curent_list.append(child_1_without_bracket)\n            else:\n                list_all_dfs.append(curent_list)\n                for i in curent_list:\n                    if (parent_1 == i):\n                        curent_list=[]\n                        curent_list.append(child_1_without_bracket)\n            child_1_without_bracket_before=child_1_without_bracket\n        \"\"\"\n        # method 1:\n        # TODO if possible use treelib\n        root = Node(\"program\")\n        nodes = {}\n        nodes[root.name] = root\n        print(parse_list)\n        parse_list.reverse()\n        for i in range(len(parse_list)):\n            print(parse_list[i])\n            top_elem=parse_list[i]\n            parent_1 = top_elem[0]\n            child_1 = top_elem[1]\n            if(len(child_1)==1):\n                child_1_without_bracket = child_1[0]\n                nodes[child_1_without_bracket] = Node(child_1_without_bracket, parent=nodes[parent_1])\n            else:\n                for i in range (len(child_1)):\n                    child_1_without_bracket = child_1[i]\n                    if(len(child_1_without_bracket)==3):\n                        l=list(child_1_without_bracket)\n                        l.pop()\n                        t = tuple(l)\n                        nodes[str(t)] = Node(str(t), parent=nodes[parent_1])\n                    else:\n                        nodes[child_1_without_bracket] = Node(child_1_without_bracket, parent=nodes[parent_1])\n        for pre, _, node in RenderTree(root):\n            print(\"%s%s\" % (pre, node.name))\n\n\n        return\n        pass\n    # method 2 draw DFS inputs\n    def add_roots(self, owner, data):\n        o = owner.setdefault(data.pop(0), {})\n        if data:\n            self.add_roots(o, data)\n\n    def show(self,base, data):\n        while data:\n            k, v = data.pop(0)\n            print('%s|-%s' % (base, k))\n            if v:\n                if data:\n                    self.show(base + '| ', v.items())\n                else:\n                    self.show(base + '  ', v.items())\n    #method 3:\n    # TODO if possible use treelib\n    \"\"\"\n    tree = Tree()\n    tree.create_node(\"program\", 0)  # root node\n    id_glob = 0\n\n    parse_list.reverse()\n    for i in range(len(parse_list)):\n        print(parse_list[i])\n        top_elem = parse_list[i]\n        id_parent = id_glob\n        parent_1 = top_elem[0]\n        child_1 = top_elem[1]\n        if (len(child_1) == 1):\n            child_1_without_bracket = child_1[0]\n            id_glob = id_glob + 1\n            tree.create_node(child_1_without_bracket, id_glob, parent=id_parent)\n        else:\n            for i in range(len(child_1)):\n                id_glob = id_glob + 1\n                child_1_without_bracket = child_1[i]\n                if (len(child_1_without_bracket) == 3):\n                    l = list(child_1_without_bracket)\n                    l.pop()\n                    t = tuple(l)\n                    tree.create_node(str(t), id_glob, parent=id_parent)\n                else:\n                    tree.create_node(child_1_without_bracket, id_glob, parent=id_parent)\n        tree.show()\n\n    return\n    pass\n    def syntax_errors(self, input_token, stack_state, error_msg):\n        # TODO fill the output error file and panic mode\n        # not sure what panic mode in 3 steps mean can apply step 1 but not sure about step 2 , 3\n        # will ask tas about it\n        print(\"error\")\n        return\n        pass\n    \"\"\"\n\"\"\"\nScanner Part\n\"\"\"\n\n# this function reads from file character by character and finds token\n# This functions returns current_position_of_cursor,Token_Type,Lexeme,current_line_position_of_cursor\ndef get_next_token(line_position, program):\n    global line_read\n    global index\n    end_of_file = len(program)\n    number = \"\"\n    identifier = \"\"\n    comment = \"\"\n    number_pattern = re.compile(\"^[0-9]$\")\n    identifier_pattern1 = re.compile(\"^[A-Za-z]$\")\n    identifier_pattern2 = re.compile(\"^[A-Za-z0-9]$\")\n    symbol_pattern = re.compile(\"^[;:,+\\-*<=/{}()\\[\\]]$\")\n    whitespace_pattern = re.compile(\"^[ \\n\\r\\t\\v\\f]$\")\n    invalids_latter = re.compile(\"^[#@!$_~&]$\")\n    char = \"\"\n    if index != end_of_file:\n        char = program[index]\n        index = index + 1\n\n    if not char and index == end_of_file:  # end of file\n        return \"$\", \"\", line_position\n    # match number\n    elif re.match(number_pattern, char):\n        number = number + char\n        while 1:\n            num_char = program[index]\n            index = index + 1\n            if re.match(number_pattern, num_char):\n                number = number + num_char\n            else:\n                if re.match(identifier_pattern1, num_char):\n                    error_input = number + num_char\n                    error_massage_table(line_position, error_input, ErrorMsg.Invalid_number)\n                    return \"\", \"\", line_position\n                elif re.match(invalids_latter, num_char):\n                    error_input = number + num_char\n                    error_massage_table(line_position, error_input, ErrorMsg.Invalid_input)\n                    return \"\", \"\", line_position\n                else:\n                    index = index - 1  # move file pointer 1 char behind current position\n                    return Token.Number, number, line_position\n    # match identifier\n    elif re.match(identifier_pattern1, char):\n        identifier = identifier + char\n        while 1:\n            identifier_char = program[index]\n            index = index + 1\n            if re.match(identifier_pattern2, identifier_char):\n                identifier = identifier + identifier_char\n            elif re.match(invalids_latter, identifier_char):\n                error_input = identifier + identifier_char\n                error_massage_table(line_position, error_input, ErrorMsg.Invalid_input)\n                return \"\", \"\", line_position\n            else:\n                index = index - 1  # move file pointer 1 char behind current position\n                # match keywords\n                if identifier == \"if\":\n                    return Token.Keyword, \"if\", line_position\n                elif identifier == \"else\":\n                    return Token.Keyword, \"else\", line_position\n                elif identifier == \"void\":\n                    return Token.Keyword, \"void\", line_position\n                elif identifier == \"int\":\n                    return Token.Keyword, \"int\", line_position\n                elif identifier == \"while\":\n                    return Token.Keyword, \"while\", line_position\n                elif identifier == \"break\":\n                    return Token.Keyword, \"break\", line_position\n                elif identifier == \"switch\":\n                    return Token.Keyword, \"switch\", line_position\n                elif identifier == \"default\":\n                    return Token.Keyword, \"default\", line_position\n                elif identifier == \"case\":\n                    return Token.Keyword, \"case\", line_position\n                elif identifier == \"return\":\n                    return Token.Keyword, \"return\", line_position\n                elif identifier == \"endif\":\n                    return Token.Keyword, \"endif\", line_position\n                symbol_table(t, identifier)\n                return Token.Identifier, identifier, line_position\n    # match symbol\n    elif re.match(symbol_pattern, char):\n        comment = comment + char\n        if char == \"=\":\n            next_char = program[index]\n            index = index + 1\n            if next_char == \"=\":\n                return Token.Symbol, \"==\", line_position\n            elif re.match(invalids_latter, next_char):\n                error_input = comment + next_char\n                error_massage_table(line_position, error_input, ErrorMsg.Invalid_input)\n                return \"\", \"\", line_position\n            else:\n                index = index - 1  # move file pointer 1 char behind current position\n                return Token.Symbol, \"=\", line_position\n        elif char == \"/\":  # match comment\n            next_char = program[index]\n            index = index + 1\n            comment = comment + next_char\n            if next_char == \"*\":\n                line_position_cpy = line_position\n                while 1:\n                    symbol_char = program[index]\n                    index = index + 1\n                    comment = comment + symbol_char\n                    if ord(symbol_char) == 10:\n                        line_position = line_position + 1\n                    if symbol_char == \"*\":\n                        symbol_char2 = program[index]\n                        index = index + 1\n                        if symbol_char2 == \"/\":\n                            return \"\", \"\", line_position\n                        continue\n                    elif index == end_of_file:\n                        error_massage_table(line_position_cpy, comment, ErrorMsg.Unclosed_comment)\n                        return \"\", \"\", line_position\n            elif next_char == \"/\":  # match comment\n                while 1:\n                    symbol_char = program[index]\n                    index = index + 1\n\n                    comment = comment + symbol_char\n                    if ord(symbol_char) == 10:\n                        line_position = line_position + 1  # it shows line position one more than real, when immediately EOF appears after it,but totaly works correct\n                        return \"\", \"\", line_position\n                    if index == end_of_file:  # end of file\n                        file.close()\n                        error_massage_table(line_position, comment, ErrorMsg.Unclosed_comment)\n                        return \"\", \"\", line_position\n                    else:\n                        continue\n            elif re.match(invalids_latter, next_char):\n                error_input = comment\n                error_massage_table(line_position, error_input, ErrorMsg.Invalid_input)\n                return \"\", \"\", line_position\n            else:\n                index = index - 1  # move file pointer 1 char behind current position\n                return Token.Symbol, char, line_position\n        elif char == \"*\":  # match comment\n            next_char = program[index]\n            index = index + 1\n            if next_char == \"/\":\n                error_massage_table(line_position, \"*/\", ErrorMsg.Unmatched_comment)\n                return \"\", \"\", line_position\n            elif re.match(invalids_latter, next_char):\n                error_input = comment + next_char\n                error_massage_table(line_position, error_input, ErrorMsg.Invalid_input)\n                return \"\", \"\", line_position\n            else:\n                index = index - 1  # move file pointer 1 char behind current position\n                return Token.Symbol, char, line_position\n        else:\n            return Token.Symbol, char, line_position\n\n    elif re.match(whitespace_pattern, char):\n        if ord(char) == 10:\n            line_position = line_position + 1\n        return \"\", \"\", line_position\n    else:\n        error_massage_table(line_position, char, ErrorMsg.Invalid_input)  # did not match any pattern\n        return \"\", \"\", line_position\n\n\ndef error_massage_table(line_number, token_until_here, error_massage):\n    lexical_errors_file = open(\"lexical_errors.txt\", \"r\")\n    content_file = lexical_errors_file.read()\n    lexical_errors_file.close()\n    global error_line\n    if content_file == \"There is no lexical error.\":\n        lexical_errors_file = open(\"lexical_errors.txt\", \"w\")\n\n        if error_massage == ErrorMsg.Invalid_input:\n            lexical_errors_file.write(\n                str(line_number) + \".\" + \"\\t\" + \"(\" + token_until_here + \", \" + error_massage + \") \")\n            error_line = line_number\n        if error_massage == ErrorMsg.Invalid_number:\n            lexical_errors_file.write(\n                str(line_number) + \".\" + \"\\t\" + \"(\" + token_until_here + \", \" + error_massage + \") \")\n            error_line = line_number\n        if error_massage == ErrorMsg.Unclosed_comment:\n            lexical_errors_file.write(\n                str(line_number) + \".\" + \"\\t\" + \"(\" + token_until_here[0:7] + \"..., \" + error_massage + \") \")\n            error_line = line_number\n        if error_massage == ErrorMsg.Unmatched_comment:\n            lexical_errors_file.write(\n                str(line_number) + \".\" + \"\\t\" + \"(\" + token_until_here + \", \" + error_massage + \") \")\n            error_line = line_number\n    else:\n\n        if error_line == line_number:\n            lexical_errors_file = open(\"lexical_errors.txt\", \"a\")\n            if error_massage == ErrorMsg.Invalid_input:\n                lexical_errors_file.write(\n                    \"(\" + token_until_here + \", \" + error_massage + \") \")\n            if error_massage == ErrorMsg.Invalid_number:\n                lexical_errors_file.write(\n                    \"(\" + token_until_here + \", \" + error_massage + \") \")\n            if error_massage == ErrorMsg.Unclosed_comment:\n                lexical_errors_file.write(\n                    \"(\" + token_until_here[0:7] + \"..., \" + error_massage + \") \")\n            if error_massage == ErrorMsg.Unmatched_comment:\n                lexical_errors_file.write(\n                    \"(\" + token_until_here + \", \" + error_massage + \") \")\n            lexical_errors_file.close()\n        else:\n            lexical_errors_file = open(\"lexical_errors.txt\", \"a\")\n            error_line = line_number\n            if error_massage == ErrorMsg.Invalid_input:\n                lexical_errors_file.write(\n                    \"\\n\" + str(line_number) + \".\" + \"\\t\" + \"(\" + token_until_here + \", \" + error_massage + \") \")\n\n            if error_massage == ErrorMsg.Invalid_number:\n                lexical_errors_file.write(\n                    \"\\n\" + str(line_number) + \".\" + \"\\t\" + \"(\" + token_until_here + \", \" + error_massage + \") \")\n            if error_massage == ErrorMsg.Unclosed_comment:\n                lexical_errors_file.write(\n                    \"\\n\" + str(line_number) + \".\" + \"\\t\" + \"(\" + token_until_here[0:7] + \"..., \" + error_massage + \") \")\n            if error_massage == ErrorMsg.Unmatched_comment:\n                lexical_errors_file.write(\n                    \"\\n\" + str(line_number) + \".\" + \"\\t\" + \"(\" + token_until_here + \", \" + error_massage + \") \")\n            lexical_errors_file.close()\n\n\ndef symbol_table(no, lexeme):  # if symbol is new then add it to the table whit appropriate line number else don't\n    symbol_table_file = open(\"symbol_table.txt\", \"a\")\n    if list_1.count(lexeme) == 0:\n        list_1.append(lexeme)\n        symbol_table_file.write(\"\\n\" + str(no) + \".\\t\" + lexeme)\n        global t\n        t = no + 1\n    symbol_table_file.close()\n\n\ndef initialize():\n    lexical_errors_file1 = open(\"lexical_errors.txt\", \"w+\")\n    lexical_errors_file1.write(\"There is no lexical error.\")\n    lexical_errors_file1.close()\n\n    symbol_table_file1 = open(\"symbol_table.txt\", \"w+\")\n    symbol_table_file1.write(\"1.\\tif\")\n    symbol_table_file1.write(\"\\n2.\\telse\")\n    symbol_table_file1.write(\"\\n3.\\tvoid\")\n    symbol_table_file1.write(\"\\n4.\\tint\")\n    symbol_table_file1.write(\"\\n5.\\twhile\")\n    symbol_table_file1.write(\"\\n6.\\tbreak\")\n    symbol_table_file1.write(\"\\n7.\\tswitch\")\n    symbol_table_file1.write(\"\\n8.\\tdefault\")\n    symbol_table_file1.write(\"\\n9.\\tcase\")\n    symbol_table_file1.write(\"\\n10.\\treturn\")\n    symbol_table_file1.write(\"\\n11.\\tendif\")\n    symbol_table_file1.close()\n\n    tokens_table_file = open(\"tokens1.txt\", \"w+\")\n    tokens_table_file.close()\n\n\ndef printing(to):\n    global current_line\n    if to[0] != \"\":\n        tokens_table_file = open(\"tokens1.txt\", \"r\")\n        content = str(tokens_table_file.read())\n        value = '\\n' + str(to[2])\n        if to[2] != current_line and not value in content:\n            if to[2] == 1:\n                tokens_table_file = open(\"tokens1.txt\", \"a\")\n                tokens_table_file.write(str(to[2]) + \".\" + \"\\t\" + \"(\" + to[0] + \", \" + to[1] + \") \")\n                current_line = current_line + 1\n                tokens_table_file.close()\n            else:\n                tokens_table_file = open(\"tokens1.txt\", \"a\")\n                tokens_table_file.write(\"\\n\" + str(to[2]) + \".\" + \"\\t\" + \"(\" + to[0] + \", \" + to[1] + \") \")\n                current_line = current_line + 1\n                tokens_table_file.close()\n        else:\n            tokens_table_file = open(\"tokens1.txt\", \"a\")\n            tokens_table_file.write(\"(\" + to[0] + \", \" + to[1] + \") \")\n            tokens_table_file.close()\n\n\nif __name__ == '__main__':\n    \" DO not change these lines\"\n    list_1 = [\"if\", \"else\", \"void\", \"int\", \"while\", \"break\", \"switch\", \"default\", \"case\", \"return\", \"endif\"]\n    initialize()\n    cursor_position = 0\n    cursor_line_position = 1\n\n    \"\"\n    line_read = 1\n    t = 12\n    error_line = 0\n    current_line = 0\n    file = open('input.txt', 'r')\n    program = file.read()\n    index = 0\n    global parse_list\n    parse_list=[]\n    \"Call the parser: \"\n    parser_obj = Parser()\n    parser_obj.parser(cursor_line_position, program)\n\n    # for witting in tokens.txt without any empty line at top of the file\n    with open('tokens1.txt', 'r') as infile, open('tokens.txt', 'w') as outfile:\n        for line in infile:\n            if not line.strip(): continue  # skip the empty line\n            outfile.write(line)  # non-empty line. Write it to output\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/compiler.py b/compiler.py
--- a/compiler.py	(revision c6755ef2735b0c695f69b98bec5b835b5bc11599)
+++ b/compiler.py	(date 1672662746590)
@@ -1,8 +1,13 @@
 import copy
 import re
 import json
-from treelib import Node, Tree
-from anytree import Node, RenderTree
+
+from anytree import Node
+
+
+# from anytree import Node, RenderTree
+
+
 # Roya Daneshi 99101557 ,Pardis Zahraei 99109777
 
 class Token:
@@ -27,11 +32,14 @@
     # WATCH OUT:  these two massage here not in the documentation format!
     Empty_parse_table = "Empty_parse_table_home"
     Empty_parse_table_goto = "Empty_parse_table_goto_home"
-    # TODO complete error massages in panic mode here base on the documentation
+    # TODO complete error massages in panic mode here base on the documentation...
+
 
 """
 PARSER PART
 """
+
+
 class Parser:
 
     def __init__(self):
@@ -67,69 +75,61 @@
         while 1:
             stack_state = self.stack[-1]  # get top of the stack
             input_token = self.input_tokens[-1]  # get top of the input tokens
-            # check validation of input:
-            if input_token[1] in self.terminals or input_token[0] == "ID" or input_token[0] == "NUM" or input_token[
-                0] == "$":
-                state_columns_tuple = self.parse_table[stack_state]
-                if input_token[1] in state_columns_tuple.keys() or input_token[0] in state_columns_tuple.keys():
-                    if input_token[0] == "ID" or input_token[0] == "NUM" or input_token[0] == "$":
-                        table_content = self.parse_table[stack_state][input_token[0]]
-                    else:
-                        table_content = self.parse_table[stack_state][input_token[1]]
-                    if table_content.startswith("shift"):
-                        shifted_token = self.input_tokens.pop()
-                        state_no = table_content.replace('shift_', '')
-                        self.stack.append(shifted_token)
-                        self.stack.append(state_no)
-                        # get nex token(call scanner):
-                        while True:
-                            current_token = get_next_token(cursor_line_position_scanner, program_input)
-                            cursor_line_position_scanner = current_token[2]
-                            if current_token[0] == "$":
-                                self.input_tokens.append(current_token)
-                                break  # end of file
-                            if current_token[1] == "":
-                                continue
-                            else:
-                                self.input_tokens.append(current_token)
-                                break
-
-                        continue
-                    elif table_content.startswith("reduce"):
-                        rule_no = table_content.replace('reduce_', '')
-                        reduce_rule = self.grammar[rule_no]
-                        if reduce_rule[2] == "epsilon":  # if the rule goes to epsilon shouldn't pop anything from stack
-                            size_pop_stack = 0
-                            non_terminal_push = reduce_rule[0]
-                            reduced_elements=["epsilon",1]
-                        else:
-                            size_pop_stack = 2 * (len(reduce_rule) - 2)
-                            non_terminal_push = reduce_rule[0]
-                            reduced_elements = self.stack[len(self.stack) - size_pop_stack:]
-
-                        self.stack = self.stack[:len(self.stack) - size_pop_stack]  # pop elements from the stack
-                        top_stack_no = self.stack[-1]  # get top of the stack state number
-                        non_terminal_goto = self.parse_table[top_stack_no]
-                        if non_terminal_push in non_terminal_goto:  # impossible error but I checked it!
-                            go_to = self.parse_table[top_stack_no][non_terminal_push]
-                            num_push = go_to.replace('goto_', '')
-                            self.stack.append(non_terminal_push)
-                            self.stack.append(num_push)
-                            parse_list.append([non_terminal_push, reduced_elements[::2]])
-
-                        else:
-                            self.syntax_errors(None, None,
-                                               ParsErrorMsg.Empty_parse_table_goto)  # empty home on goto table
-                        continue
-
-                    elif table_content.startswith("accept"):
-                        # parse completed!
-                        self.parse_tree()
-                        print("parse completed!")
-                        return 0  # say parse is finished
-
-                else:  # empty home in table
-                    self.syntax_errors(input_token, stack_state, ParsErrorMsg.Empty_parse_table)
+            state_columns_tuple = self.parse_table[stack_state]
+            if input_token[1] in state_columns_tuple.keys() or input_token[0] in state_columns_tuple.keys():
+                if input_token[0] == "ID" or input_token[0] == "NUM" or input_token[0] == "$":
+                    table_content = self.parse_table[stack_state][input_token[0]]
+                else:
+                    table_content = self.parse_table[stack_state][input_token[1]]
+                if table_content.startswith("shift"):
+                    shifted_token = self.input_tokens.pop()
+                    state_no = table_content.replace('shift_', '')
+                    self.stack.append(shifted_token)
+                    self.stack.append(state_no)
+                    # get nex token(call scanner):
+                    while True:
+                        current_token = get_next_token(cursor_line_position_scanner, program_input)
+                        cursor_line_position_scanner = current_token[2]
+                        if current_token[0] == "$":
+                            self.input_tokens.append(current_token)
+                            break  # end of file
+                        if current_token[1] == "":
+                            continue
+                        else:
+                            self.input_tokens.append(current_token)
+                            break
+                    continue
+                elif table_content.startswith("reduce"):
+                    rule_no = table_content.replace('reduce_', '')
+                    reduce_rule = self.grammar[rule_no]
+                    if reduce_rule[2] == "epsilon":  # if the rule goes to epsilon shouldn't pop anything from stack
+                        size_pop_stack = 0
+                        non_terminal_push = reduce_rule[0]
+                        reduced_elements = ["epsilon", 1]
+                    else:
+                        size_pop_stack = 2 * (len(reduce_rule) - 2)
+                        non_terminal_push = reduce_rule[0]
+                        reduced_elements = self.stack[len(self.stack) - size_pop_stack:]
+                    self.stack = self.stack[:len(self.stack) - size_pop_stack]  # pop elements from the stack
+                    top_stack_no = self.stack[-1]  # get top of the stack state number
+                    non_terminal_goto = self.parse_table[top_stack_no]
+                    if non_terminal_push in non_terminal_goto:  # impossible error but I checked it!
+                        go_to = self.parse_table[top_stack_no][non_terminal_push]
+                        num_push = go_to.replace('goto_', '')
+                        self.stack.append(non_terminal_push)
+                        self.stack.append(num_push)
+                        parse_list.append([non_terminal_push, reduced_elements[::2]])
+                    else:
+                        self.syntax_errors(None, None,
+                                           ParsErrorMsg.Empty_parse_table_goto)  # empty home on goto table
+                    continue
+                elif table_content.startswith("accept"):
+                    # parse completed!
+                    self.parse_tree()
+                    print("parse completed!")
+                    return 0  # say parse is finished
+            else:  # empty home in table
+                self.syntax_errors(input_token, stack_state, ParsErrorMsg.Empty_parse_table)
 
     def read_json_file(self):  # DONE  # this func called in init function at first.
         f = open('table.json')
@@ -191,17 +191,17 @@
         parse_list.reverse()
         for i in range(len(parse_list)):
             print(parse_list[i])
-            top_elem=parse_list[i]
+            top_elem = parse_list[i]
             parent_1 = top_elem[0]
             child_1 = top_elem[1]
-            if(len(child_1)==1):
+            if (len(child_1) == 1):
                 child_1_without_bracket = child_1[0]
                 nodes[child_1_without_bracket] = Node(child_1_without_bracket, parent=nodes[parent_1])
             else:
-                for i in range (len(child_1)):
+                for i in range(len(child_1)):
                     child_1_without_bracket = child_1[i]
-                    if(len(child_1_without_bracket)==3):
-                        l=list(child_1_without_bracket)
+                    if (len(child_1_without_bracket) == 3):
+                        l = list(child_1_without_bracket)
                         l.pop()
                         t = tuple(l)
                         nodes[str(t)] = Node(str(t), parent=nodes[parent_1])
@@ -210,16 +210,16 @@
         for pre, _, node in RenderTree(root):
             print("%s%s" % (pre, node.name))
 
-
         return
         pass
+
     # method 2 draw DFS inputs
     def add_roots(self, owner, data):
         o = owner.setdefault(data.pop(0), {})
         if data:
             self.add_roots(o, data)
 
-    def show(self,base, data):
+    def show(self, base, data):
         while data:
             k, v = data.pop(0)
             print('%s|-%s' % (base, k))
@@ -228,7 +228,8 @@
                     self.show(base + '| ', v.items())
                 else:
                     self.show(base + '  ', v.items())
-    #method 3:
+
+    # method 3:
     # TODO if possible use treelib
     """
     tree = Tree()
@@ -269,10 +270,13 @@
         return
         pass
     """
+
+
 """
 Scanner Part
 """
 
+
 # this function reads from file character by character and finds token
 # This functions returns current_position_of_cursor,Token_Type,Lexeme,current_line_position_of_cursor
 def get_next_token(line_position, program):
@@ -569,7 +573,7 @@
     program = file.read()
     index = 0
     global parse_list
-    parse_list=[]
+    parse_list = []
     "Call the parser: "
     parser_obj = Parser()
     parser_obj.parser(cursor_line_position, program)
@@ -579,4 +583,3 @@
         for line in infile:
             if not line.strip(): continue  # skip the empty line
             outfile.write(line)  # non-empty line. Write it to output
-
Index: .idea/compiler_phase1.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<module type=\"PYTHON_MODULE\" version=\"4\">\n  <component name=\"NewModuleRootManager\">\n    <content url=\"file://$MODULE_DIR$\" />\n    <orderEntry type=\"jdk\" jdkName=\"Python 3.10\" jdkType=\"Python SDK\" />\n    <orderEntry type=\"sourceFolder\" forTests=\"false\" />\n  </component>\n</module>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/compiler_phase1.iml b/.idea/compiler_phase1.iml
--- a/.idea/compiler_phase1.iml	(revision c6755ef2735b0c695f69b98bec5b835b5bc11599)
+++ b/.idea/compiler_phase1.iml	(date 1672575201096)
@@ -2,7 +2,7 @@
 <module type="PYTHON_MODULE" version="4">
   <component name="NewModuleRootManager">
     <content url="file://$MODULE_DIR$" />
-    <orderEntry type="jdk" jdkName="Python 3.10" jdkType="Python SDK" />
+    <orderEntry type="jdk" jdkName="Python 3.8 (compiler_phase11)" jdkType="Python SDK" />
     <orderEntry type="sourceFolder" forTests="false" />
   </component>
 </module>
\ No newline at end of file
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"ProjectRootManager\" version=\"2\" project-jdk-name=\"Python 3.10\" project-jdk-type=\"Python SDK\" />\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/misc.xml b/.idea/misc.xml
--- a/.idea/misc.xml	(revision c6755ef2735b0c695f69b98bec5b835b5bc11599)
+++ b/.idea/misc.xml	(date 1672575201116)
@@ -1,4 +1,4 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
-  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.10" project-jdk-type="Python SDK" />
+  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.8 (compiler_phase11)" project-jdk-type="Python SDK" />
 </project>
\ No newline at end of file
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"AutoImportSettings\">\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\n  </component>\n  <component name=\"ChangeListManager\">\n    <list default=\"true\" id=\"b446052b-eb3f-4e36-b535-52181b0f5e3b\" name=\"Changes\" comment=\"3 methods added\">\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\n    </list>\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\n  </component>\n  <component name=\"Git.Settings\">\n    <option name=\"RECENT_BRANCH_BY_REPOSITORY\">\n      <map>\n        <entry key=\"$PROJECT_DIR$\" value=\"phase1\" />\n      </map>\n    </option>\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\n  </component>\n  <component name=\"MarkdownSettingsMigration\">\n    <option name=\"stateVersion\" value=\"1\" />\n  </component>\n  <component name=\"ProjectId\" id=\"2HfBOaIlLXTJu6sKq3EjvqslgG1\" />\n  <component name=\"ProjectLevelVcsManager\">\n    <ConfirmationsSetting value=\"2\" id=\"Add\" />\n  </component>\n  <component name=\"ProjectViewState\">\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\n    <option name=\"showLibraryContents\" value=\"true\" />\n  </component>\n  <component name=\"PropertiesComponent\">\n    <property name=\"WebServerToolWindowFactoryState\" value=\"false\" />\n  </component>\n  <component name=\"RunManager\">\n    <configuration name=\"compiler\" type=\"PythonConfigurationType\" factoryName=\"Python\" nameIsGenerated=\"true\">\n      <module name=\"compiler_phase1\" />\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\n      <option name=\"PARENT_ENVS\" value=\"true\" />\n      <envs>\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\n      </envs>\n      <option name=\"SDK_HOME\" value=\"$PROJECT_DIR$/../kafkaProducer/venv/bin/python\" />\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" />\n      <option name=\"IS_MODULE_SDK\" value=\"false\" />\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\n      <EXTENSION ID=\"PythonCoverageRunConfigurationExtension\" runner=\"coverage.py\" />\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/compiler.py\" />\n      <option name=\"PARAMETERS\" value=\"\" />\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\n      <option name=\"MODULE_MODE\" value=\"false\" />\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\n      <option name=\"INPUT_FILE\" value=\"\" />\n      <method v=\"2\" />\n    </configuration>\n  </component>\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\n  <component name=\"TaskManager\">\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\n      <changelist id=\"b446052b-eb3f-4e36-b535-52181b0f5e3b\" name=\"Changes\" comment=\"\" />\n      <created>1668666226320</created>\n      <option name=\"number\" value=\"Default\" />\n      <option name=\"presentableId\" value=\"Default\" />\n      <updated>1668666226320</updated>\n      <workItem from=\"1668841336589\" duration=\"1048000\" />\n      <workItem from=\"1668872856867\" duration=\"99000\" />\n      <workItem from=\"1668872967665\" duration=\"1548000\" />\n      <workItem from=\"1669137839545\" duration=\"4000\" />\n      <workItem from=\"1669320961721\" duration=\"24000\" />\n      <workItem from=\"1672501583349\" duration=\"72000\" />\n      <workItem from=\"1672501661255\" duration=\"2000\" />\n      <workItem from=\"1672525946999\" duration=\"97000\" />\n      <workItem from=\"1672552590360\" duration=\"3000\" />\n      <workItem from=\"1672570683753\" duration=\"61000\" />\n      <workItem from=\"1672571000240\" duration=\"182000\" />\n    </task>\n    <task id=\"LOCAL-00001\" summary=\"add scanner code to read char by char from file and recognize the token\">\n      <created>1668672673882</created>\n      <option name=\"number\" value=\"00001\" />\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1668672673882</updated>\n    </task>\n    <task id=\"LOCAL-00002\" summary=\"fix some error in scanner\">\n      <created>1668673329177</created>\n      <option name=\"number\" value=\"00002\" />\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1668673329177</updated>\n    </task>\n    <task id=\"LOCAL-00003\" summary=\"fix some error in scanner\">\n      <created>1668676261730</created>\n      <option name=\"number\" value=\"00003\" />\n      <option name=\"presentableId\" value=\"LOCAL-00003\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1668676261730</updated>\n    </task>\n    <task id=\"LOCAL-00004\" summary=\"fix some error in scanner\">\n      <created>1668676289957</created>\n      <option name=\"number\" value=\"00004\" />\n      <option name=\"presentableId\" value=\"LOCAL-00004\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1668676289957</updated>\n    </task>\n    <task id=\"LOCAL-00005\" summary=\"fix some error in scanner\">\n      <created>1668677743674</created>\n      <option name=\"number\" value=\"00005\" />\n      <option name=\"presentableId\" value=\"LOCAL-00005\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1668677743674</updated>\n    </task>\n    <task id=\"LOCAL-00006\" summary=\"complete finding token and making error table and symbol table\">\n      <created>1668687532046</created>\n      <option name=\"number\" value=\"00006\" />\n      <option name=\"presentableId\" value=\"LOCAL-00006\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1668687532046</updated>\n    </task>\n    <task id=\"LOCAL-00007\" summary=\"debug get token\">\n      <created>1668690286170</created>\n      <option name=\"number\" value=\"00007\" />\n      <option name=\"presentableId\" value=\"LOCAL-00007\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1668690286170</updated>\n    </task>\n    <task id=\"LOCAL-00008\" summary=\"get_next_token and error_massage_table and symbol table are completed.\">\n      <created>1668692833415</created>\n      <option name=\"number\" value=\"00008\" />\n      <option name=\"presentableId\" value=\"LOCAL-00008\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1668692833415</updated>\n    </task>\n    <task id=\"LOCAL-00009\" summary=\"complete version\">\n      <created>1668873067713</created>\n      <option name=\"number\" value=\"00009\" />\n      <option name=\"presentableId\" value=\"LOCAL-00009\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1668873067713</updated>\n    </task>\n    <task id=\"LOCAL-00010\" summary=\"other files\">\n      <created>1668874397737</created>\n      <option name=\"number\" value=\"00010\" />\n      <option name=\"presentableId\" value=\"LOCAL-00010\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1668874397737</updated>\n    </task>\n    <task id=\"LOCAL-00011\" summary=\"resolve error of symbol : after default\">\n      <created>1669363353242</created>\n      <option name=\"number\" value=\"00011\" />\n      <option name=\"presentableId\" value=\"LOCAL-00011\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1669363353242</updated>\n    </task>\n    <task id=\"LOCAL-00012\" summary=\"complete\">\n      <created>1669468479929</created>\n      <option name=\"number\" value=\"00012\" />\n      <option name=\"presentableId\" value=\"LOCAL-00012\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1669468479930</updated>\n    </task>\n    <task id=\"LOCAL-00013\" summary=\"resolve error reorganization of testcase12\">\n      <created>1669470110127</created>\n      <option name=\"number\" value=\"00013\" />\n      <option name=\"presentableId\" value=\"LOCAL-00013\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1669470110127</updated>\n    </task>\n    <task id=\"LOCAL-00014\" summary=\"resolve error line number of lexical error of testcase11\">\n      <created>1669471291481</created>\n      <option name=\"number\" value=\"00014\" />\n      <option name=\"presentableId\" value=\"LOCAL-00014\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1669471291481</updated>\n    </task>\n    <task id=\"LOCAL-00015\" summary=\"resolve error line number of lexical error of testcase11\">\n      <created>1669471468784</created>\n      <option name=\"number\" value=\"00015\" />\n      <option name=\"presentableId\" value=\"LOCAL-00015\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1669471468784</updated>\n    </task>\n    <task id=\"LOCAL-00016\" summary=\"resolve error of space in end of lexical_errors\">\n      <created>1669471824715</created>\n      <option name=\"number\" value=\"00016\" />\n      <option name=\"presentableId\" value=\"LOCAL-00016\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1669471824716</updated>\n    </task>\n    <task id=\"LOCAL-00017\" summary=\"resolve error reorganization\">\n      <created>1669472674481</created>\n      <option name=\"number\" value=\"00017\" />\n      <option name=\"presentableId\" value=\"LOCAL-00017\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1669472674481</updated>\n    </task>\n    <task id=\"LOCAL-00018\" summary=\"resolve error reorganization\">\n      <created>1669472988205</created>\n      <option name=\"number\" value=\"00018\" />\n      <option name=\"presentableId\" value=\"LOCAL-00018\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1669472988205</updated>\n    </task>\n    <task id=\"LOCAL-00019\" summary=\"resolve space\">\n      <created>1669473885176</created>\n      <option name=\"number\" value=\"00019\" />\n      <option name=\"presentableId\" value=\"LOCAL-00019\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1669473885176</updated>\n    </task>\n    <task id=\"LOCAL-00020\" summary=\"phase1\">\n      <created>1670497629132</created>\n      <option name=\"number\" value=\"00020\" />\n      <option name=\"presentableId\" value=\"LOCAL-00020\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1670497629132</updated>\n    </task>\n    <task id=\"LOCAL-00021\" summary=\"write TODO for phase2\">\n      <created>1670499873758</created>\n      <option name=\"number\" value=\"00021\" />\n      <option name=\"presentableId\" value=\"LOCAL-00021\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1670499873758</updated>\n    </task>\n    <task id=\"LOCAL-00022\" summary=\"make by bison table.json\">\n      <created>1671533227560</created>\n      <option name=\"number\" value=\"00022\" />\n      <option name=\"presentableId\" value=\"LOCAL-00022\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1671533227560</updated>\n    </task>\n    <task id=\"LOCAL-00023\" summary=\"make by bison table.json\">\n      <created>1671533418418</created>\n      <option name=\"number\" value=\"00023\" />\n      <option name=\"presentableId\" value=\"LOCAL-00023\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1671533418418</updated>\n    </task>\n    <task id=\"LOCAL-00024\" summary=\"make by bison table.json\">\n      <created>1671533496487</created>\n      <option name=\"number\" value=\"00024\" />\n      <option name=\"presentableId\" value=\"LOCAL-00024\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1671533496487</updated>\n    </task>\n    <task id=\"LOCAL-00025\" summary=\"fill properties from json file\">\n      <created>1671535268989</created>\n      <option name=\"number\" value=\"00025\" />\n      <option name=\"presentableId\" value=\"LOCAL-00025\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1671535268989</updated>\n    </task>\n    <task id=\"LOCAL-00026\" summary=\"add parser code function and read json file\">\n      <created>1671541345538</created>\n      <option name=\"number\" value=\"00026\" />\n      <option name=\"presentableId\" value=\"LOCAL-00026\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1671541345538</updated>\n    </task>\n    <task id=\"LOCAL-00027\" summary=\"add parser code function and read json file\">\n      <created>1671545578822</created>\n      <option name=\"number\" value=\"00027\" />\n      <option name=\"presentableId\" value=\"LOCAL-00027\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1671545578822</updated>\n    </task>\n    <task id=\"LOCAL-00028\" summary=\"debug parser\">\n      <created>1671548780845</created>\n      <option name=\"number\" value=\"00028\" />\n      <option name=\"presentableId\" value=\"LOCAL-00028\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1671548780845</updated>\n    </task>\n    <task id=\"LOCAL-00029\" summary=\"debug parser\">\n      <created>1671548845068</created>\n      <option name=\"number\" value=\"00029\" />\n      <option name=\"presentableId\" value=\"LOCAL-00029\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1671548845068</updated>\n    </task>\n    <task id=\"LOCAL-00030\" summary=\"only token problem\">\n      <created>1672451303584</created>\n      <option name=\"number\" value=\"00030\" />\n      <option name=\"presentableId\" value=\"LOCAL-00030\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1672451303584</updated>\n    </task>\n    <task id=\"LOCAL-00031\" summary=\"if treelib ok, only errors left\">\n      <created>1672526017706</created>\n      <option name=\"number\" value=\"00031\" />\n      <option name=\"presentableId\" value=\"LOCAL-00031\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1672526017706</updated>\n    </task>\n    <task id=\"LOCAL-00032\" summary=\"if treelib ok, only errors left\">\n      <created>1672570706444</created>\n      <option name=\"number\" value=\"00032\" />\n      <option name=\"presentableId\" value=\"LOCAL-00032\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1672570706444</updated>\n    </task>\n    <option name=\"localTasksCounter\" value=\"33\" />\n    <servers />\n  </component>\n  <component name=\"TypeScriptGeneratedFilesManager\">\n    <option name=\"version\" value=\"3\" />\n  </component>\n  <component name=\"Vcs.Log.Tabs.Properties\">\n    <option name=\"TAB_STATES\">\n      <map>\n        <entry key=\"MAIN\">\n          <value>\n            <State />\n          </value>\n        </entry>\n      </map>\n    </option>\n  </component>\n  <component name=\"VcsManagerConfiguration\">\n    <option name=\"ADD_EXTERNAL_FILES_SILENTLY\" value=\"true\" />\n    <MESSAGE value=\"add scanner code to read char by char from file and recognize the token\" />\n    <MESSAGE value=\"fix some error in scanner\" />\n    <MESSAGE value=\"complete finding token and making error table and symbol table\" />\n    <MESSAGE value=\"debug get token\" />\n    <MESSAGE value=\"get_next_token and error_massage_table and symbol table are completed.\" />\n    <MESSAGE value=\"complete version\" />\n    <MESSAGE value=\"other files\" />\n    <MESSAGE value=\"resolve error of symbol : after default\" />\n    <MESSAGE value=\"complete\" />\n    <MESSAGE value=\"resolve error reorganization of testcase12\" />\n    <MESSAGE value=\"resolve error line number of lexical error of testcase11\" />\n    <MESSAGE value=\"resolve error of space in end of lexical_errors\" />\n    <MESSAGE value=\"resolve error reorganization\" />\n    <MESSAGE value=\"resolve space\" />\n    <MESSAGE value=\"phase1\" />\n    <MESSAGE value=\"write TODO for phase2\" />\n    <MESSAGE value=\"make by bison table.json\" />\n    <MESSAGE value=\"fill properties from json file\" />\n    <MESSAGE value=\"add parser code function and read json file\" />\n    <MESSAGE value=\"debug parser\" />\n    <MESSAGE value=\"only token problem\" />\n    <MESSAGE value=\"if treelib ok, only errors left\" />\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"if treelib ok, only errors left\" />\n  </component>\n  <component name=\"com.intellij.coverage.CoverageDataManagerImpl\">\n    <SUITE FILE_PATH=\"coverage/compiler_project$main.coverage\" NAME=\"main Coverage Results\" MODIFIED=\"1669468843385\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"true\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$\" />\n  </component>\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision c6755ef2735b0c695f69b98bec5b835b5bc11599)
+++ b/.idea/workspace.xml	(date 1672662747086)
@@ -6,6 +6,7 @@
   <component name="ChangeListManager">
     <list default="true" id="b446052b-eb3f-4e36-b535-52181b0f5e3b" name="Changes" comment="3 methods added">
       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/compiler.py" beforeDir="false" afterPath="$PROJECT_DIR$/compiler.py" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
@@ -19,6 +20,9 @@
       </map>
     </option>
     <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
+  </component>
+  <component name="HighlightingSettingsPerFile">
+    <setting file="file://$PROJECT_DIR$/compiler.py" root0="FORCE_HIGHLIGHTING" />
   </component>
   <component name="MarkdownSettingsMigration">
     <option name="stateVersion" value="1" />
@@ -31,9 +35,11 @@
     <option name="hideEmptyMiddlePackages" value="true" />
     <option name="showLibraryContents" value="true" />
   </component>
-  <component name="PropertiesComponent">
-    <property name="WebServerToolWindowFactoryState" value="false" />
-  </component>
+  <component name="PropertiesComponent">{
+  &quot;keyToString&quot;: {
+    &quot;last_opened_file_path&quot;: &quot;/home/ubuntu/term5/AI/HW4 (1)/Regression&quot;
+  }
+}</component>
   <component name="RunManager">
     <configuration name="compiler" type="PythonConfigurationType" factoryName="Python" nameIsGenerated="true">
       <module name="compiler_phase1" />
@@ -345,7 +351,4 @@
     <MESSAGE value="if treelib ok, only errors left" />
     <option name="LAST_COMMIT_MESSAGE" value="if treelib ok, only errors left" />
   </component>
-  <component name="com.intellij.coverage.CoverageDataManagerImpl">
-    <SUITE FILE_PATH="coverage/compiler_project$main.coverage" NAME="main Coverage Results" MODIFIED="1669468843385" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="true" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
-  </component>
 </project>
\ No newline at end of file
