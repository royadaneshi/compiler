Index: compiler.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import re\nimport json\n\n\n# Pardis Zahraei 99109777 , Roya Daneshi 99101557\n\nclass Token:\n    Invalid = 'Invalid'\n    EndOfFile = 'EOF'\n    Number = 'NUM'\n    Identifier = 'ID'\n    Keyword = 'KEYWORD'\n    Symbol = 'SYMBOL'\n    Comment = 'COMMENT'\n    Whitespace = 'WHITESPACE'\n\n\nclass ErrorMsg:\n    Invalid_input = 'Invalid input'\n    Unclosed_comment = 'Unclosed comment'\n    Unmatched_comment = 'Unmatched comment'\n    Invalid_number = 'Invalid number'\n\n\nclass ParsErrorMsg:\n    # WATCH OUT:  these two massage here not in the documentation format!\n    Empty_parse_table = \"Empty_parse_table_home\"\n    Empty_parse_table_goto = \"Empty_parse_table_goto_home\"\n    # TODO complete error massages in panic mode here base on the documentation\n\n\nclass Parser:\n\n    def __init__(self):\n        self.follow = None\n        self.first = None\n        self.grammar = None\n        self.terminals = None\n        self.non_terminals = None\n        self.parse_table = None\n        self.read_json_file()\n        self.stack = None\n        self.input_tokens = None\n\n    def parser(self, cursor_line_position_scanner, program_input):  # DONE\n\n        self.stack = []\n        self.stack.append(\"$\")  # initialize stack at start state\n        self.stack.append(\"0\")\n        self.input_tokens = []\n        # self.input_tokens.append(\"$\")  # is it necessary?\n        while True:\n            first_token = get_next_token(cursor_line_position_scanner, program_input)\n            cursor_line_position_scanner = first_token[2]\n            if first_token[0] == \"$\":\n                self.input_tokens.append(first_token)\n                break  # end of file\n            if first_token[1] == \"\":\n                continue\n            else:\n                self.input_tokens.append(first_token)\n                break\n\n        while 1:\n            stack_state = self.stack[-1]  # get top of the stack\n            input_token = self.input_tokens[-1]  # get top of the input tokens\n            # check validation of input:\n            if input_token[1] in self.terminals or input_token[0] == \"ID\" or input_token[0] == \"NUM\" or input_token[\n                0] == \"$\":\n                state_columns_tuple = self.parse_table[stack_state]\n                if input_token[1] in state_columns_tuple.keys() or input_token[0] in state_columns_tuple.keys():\n                    if input_token[0] == \"ID\" or input_token[0] == \"NUM\" or input_token[0] == \"$\":\n                        table_content = self.parse_table[stack_state][input_token[0]]\n                    else:\n                        table_content = self.parse_table[stack_state][input_token[1]]\n                    if table_content.startswith(\"shift\"):\n                        shifted_token = self.input_tokens.pop()\n                        state_no = table_content.replace('shift_', '')\n                        self.stack.append(shifted_token)\n                        self.stack.append(state_no)\n                        # get nex token(call scanner):\n                        while True:\n                            current_token = get_next_token(cursor_line_position_scanner, program_input)\n                            cursor_line_position_scanner = current_token[2]\n                            if current_token[0] == \"$\":\n                                self.input_tokens.append(current_token)\n                                break  # end of file\n                            if current_token[1] == \"\":\n                                continue\n                            else:\n                                self.input_tokens.append(current_token)\n                                break\n\n                        continue\n                    elif table_content.startswith(\"reduce\"):\n                        rule_no = table_content.replace('reduce_', '')\n                        reduce_rule = self.grammar[rule_no]\n                        if reduce_rule[2] == \"epsilon\":  # if the rule goes to epsilon shouldn't pop anything from stack\n                            size_pop_stack = 0\n                        else:\n                            size_pop_stack = 2 * (len(reduce_rule) - 2)\n                        non_terminal_push = reduce_rule[0]\n                        reduced_elements = self.stack[len(self.stack) - size_pop_stack:]\n                        self.stack = self.stack[:len(self.stack) - size_pop_stack]  # pop elements from the stack\n                        top_stack_no = self.stack[-1]  # get top of the stack state number\n                        non_terminal_goto = self.parse_table[top_stack_no]\n                        if non_terminal_push in non_terminal_goto:  # impossible error but I checked it!\n                            go_to = self.parse_table[top_stack_no][non_terminal_push]\n                            num_push = go_to.replace('goto_', '')\n                            self.stack.append(non_terminal_push)\n                            self.stack.append(num_push)\n                            self.parse_tree(non_terminal_push, reduced_elements[::2])\n                        else:\n                            self.syntax_errors(None, None,\n                                               ParsErrorMsg.Empty_parse_table_goto)  # empty home on goto table\n                        continue\n\n                    elif table_content.startswith(\"accept\"):\n                        # parse completed!\n                        print(\"parse completed!\")\n                        return 0  # say parse is finished\n\n                else:  # empty home in table\n                    self.syntax_errors(input_token, stack_state, ParsErrorMsg.Empty_parse_table)\n\n    def read_json_file(self):  # DONE  # this func called in init function at first.\n        f = open('table.json')\n        data = json.load(f)\n        self.terminals = data[\"terminals\"]\n        self.non_terminals = data[\"non_terminals\"]\n        self.first = data[\"first\"]\n        self.follow = data[\"follow\"]\n        self.grammar = data[\"grammar\"]\n        self.parse_table = data[\"parse_table\"]\n        f.close()\n\n    def parse_tree(self, root, children):\n        # TODO make the parse tree and write in a output file\n        print(\"parse tree\")\n        return\n        pass\n\n    def syntax_errors(self, input_token, stack_state, error_msg):\n        # TODO fill the output error file and panic mode\n        print(\"error\")\n        return\n        pass\n\n\n# this function reads from file character by character and finds token\n# This functions returns current_position_of_cursor,Token_Type,Lexeme,current_line_position_of_cursor\ndef get_next_token(line_position, program):\n    global line_read\n    global index\n    end_of_file = len(program)\n    number = \"\"\n    identifier = \"\"\n    comment = \"\"\n    number_pattern = re.compile(\"^[0-9]$\")\n    identifier_pattern1 = re.compile(\"^[A-Za-z]$\")\n    identifier_pattern2 = re.compile(\"^[A-Za-z0-9]$\")\n    symbol_pattern = re.compile(\"^[;:,+\\-*<=/{}()\\[\\]]$\")\n    whitespace_pattern = re.compile(\"^[ \\n\\r\\t\\v\\f]$\")\n    invalids_latter = re.compile(\"^[#@!$_~&]$\")\n    char = \"\"\n    if index != end_of_file:\n        char = program[index]\n        index = index + 1\n\n    if not char and index == end_of_file:  # end of file\n        return \"$\", \"\", line_position\n    # match number\n    elif re.match(number_pattern, char):\n        number = number + char\n        while 1:\n            num_char = program[index]\n            index = index + 1\n            if re.match(number_pattern, num_char):\n                number = number + num_char\n            else:\n                if re.match(identifier_pattern1, num_char):\n                    error_input = number + num_char\n                    error_massage_table(line_position, error_input, ErrorMsg.Invalid_number)\n                    return \"\", \"\", line_position\n                elif re.match(invalids_latter, num_char):\n                    error_input = number + num_char\n                    error_massage_table(line_position, error_input, ErrorMsg.Invalid_input)\n                    return \"\", \"\", line_position\n                else:\n                    index = index - 1  # move file pointer 1 char behind current position\n                    return Token.Number, number, line_position\n    # match identifier\n    elif re.match(identifier_pattern1, char):\n        identifier = identifier + char\n        while 1:\n            identifier_char = program[index]\n            index = index + 1\n            if re.match(identifier_pattern2, identifier_char):\n                identifier = identifier + identifier_char\n            elif re.match(invalids_latter, identifier_char):\n                error_input = identifier + identifier_char\n                error_massage_table(line_position, error_input, ErrorMsg.Invalid_input)\n                return \"\", \"\", line_position\n            else:\n                index = index - 1  # move file pointer 1 char behind current position\n                # match keywords\n                if identifier == \"if\":\n                    return Token.Keyword, \"if\", line_position\n                elif identifier == \"else\":\n                    return Token.Keyword, \"else\", line_position\n                elif identifier == \"void\":\n                    return Token.Keyword, \"void\", line_position\n                elif identifier == \"int\":\n                    return Token.Keyword, \"int\", line_position\n                elif identifier == \"while\":\n                    return Token.Keyword, \"while\", line_position\n                elif identifier == \"break\":\n                    return Token.Keyword, \"break\", line_position\n                elif identifier == \"switch\":\n                    return Token.Keyword, \"switch\", line_position\n                elif identifier == \"default\":\n                    return Token.Keyword, \"default\", line_position\n                elif identifier == \"case\":\n                    return Token.Keyword, \"case\", line_position\n                elif identifier == \"return\":\n                    return Token.Keyword, \"return\", line_position\n                elif identifier == \"endif\":\n                    return Token.Keyword, \"endif\", line_position\n                symbol_table(t, identifier)\n                return Token.Identifier, identifier, line_position\n    # match symbol\n    elif re.match(symbol_pattern, char):\n        comment = comment + char\n        if char == \"=\":\n            next_char = program[index]\n            index = index + 1\n            if next_char == \"=\":\n                return Token.Symbol, \"==\", line_position\n            elif re.match(invalids_latter, next_char):\n                error_input = comment + next_char\n                error_massage_table(line_position, error_input, ErrorMsg.Invalid_input)\n                return \"\", \"\", line_position\n            else:\n                index = index - 1  # move file pointer 1 char behind current position\n                return Token.Symbol, \"=\", line_position\n        elif char == \"/\":  # match comment\n            next_char = program[index]\n            index = index + 1\n            comment = comment + next_char\n            if next_char == \"*\":\n                line_position_cpy = line_position\n                while 1:\n                    symbol_char = program[index]\n                    index = index + 1\n                    comment = comment + symbol_char\n                    if ord(symbol_char) == 10:\n                        line_position = line_position + 1\n                    if symbol_char == \"*\":\n                        symbol_char2 = program[index]\n                        index = index + 1\n                        if symbol_char2 == \"/\":\n                            return \"\", \"\", line_position\n                        continue\n                    elif index == end_of_file:\n                        error_massage_table(line_position_cpy, comment, ErrorMsg.Unclosed_comment)\n                        return \"\", \"\", line_position\n            elif next_char == \"/\":  # match comment\n                while 1:\n                    symbol_char = program[index]\n                    index = index + 1\n\n                    comment = comment + symbol_char\n                    if ord(symbol_char) == 10:\n                        line_position = line_position + 1  # it shows line position one more than real, when immediately EOF appears after it,but totaly works correct\n                        return \"\", \"\", line_position\n                    if index == end_of_file:  # end of file\n                        file.close()\n                        error_massage_table(line_position, comment, ErrorMsg.Unclosed_comment)\n                        return \"\", \"\", line_position\n                    else:\n                        continue\n            elif re.match(invalids_latter, next_char):\n                error_input = comment\n                error_massage_table(line_position, error_input, ErrorMsg.Invalid_input)\n                return \"\", \"\", line_position\n            else:\n                index = index - 1  # move file pointer 1 char behind current position\n                return Token.Symbol, char, line_position\n        elif char == \"*\":  # match comment\n            next_char = program[index]\n            index = index + 1\n            if next_char == \"/\":\n                error_massage_table(line_position, \"*/\", ErrorMsg.Unmatched_comment)\n                return \"\", \"\", line_position\n            elif re.match(invalids_latter, next_char):\n                error_input = comment + next_char\n                error_massage_table(line_position, error_input, ErrorMsg.Invalid_input)\n                return \"\", \"\", line_position\n            else:\n                index = index - 1  # move file pointer 1 char behind current position\n                return Token.Symbol, char, line_position\n        else:\n            return Token.Symbol, char, line_position\n\n    elif re.match(whitespace_pattern, char):\n        if ord(char) == 10:\n            line_position = line_position + 1\n        return \"\", \"\", line_position\n    else:\n        error_massage_table(line_position, char, ErrorMsg.Invalid_input)  # did not match any pattern\n        return \"\", \"\", line_position\n\n\ndef error_massage_table(line_number, token_until_here, error_massage):\n    lexical_errors_file = open(\"lexical_errors.txt\", \"r\")\n    content_file = lexical_errors_file.read()\n    lexical_errors_file.close()\n    global error_line\n    if content_file == \"There is no lexical error.\":\n        lexical_errors_file = open(\"lexical_errors.txt\", \"w\")\n\n        if error_massage == ErrorMsg.Invalid_input:\n            lexical_errors_file.write(\n                str(line_number) + \".\" + \"\\t\" + \"(\" + token_until_here + \", \" + error_massage + \") \")\n            error_line = line_number\n        if error_massage == ErrorMsg.Invalid_number:\n            lexical_errors_file.write(\n                str(line_number) + \".\" + \"\\t\" + \"(\" + token_until_here + \", \" + error_massage + \") \")\n            error_line = line_number\n        if error_massage == ErrorMsg.Unclosed_comment:\n            lexical_errors_file.write(\n                str(line_number) + \".\" + \"\\t\" + \"(\" + token_until_here[0:7] + \"..., \" + error_massage + \") \")\n            error_line = line_number\n        if error_massage == ErrorMsg.Unmatched_comment:\n            lexical_errors_file.write(\n                str(line_number) + \".\" + \"\\t\" + \"(\" + token_until_here + \", \" + error_massage + \") \")\n            error_line = line_number\n    else:\n\n        if error_line == line_number:\n            lexical_errors_file = open(\"lexical_errors.txt\", \"a\")\n            if error_massage == ErrorMsg.Invalid_input:\n                lexical_errors_file.write(\n                    \"(\" + token_until_here + \", \" + error_massage + \") \")\n            if error_massage == ErrorMsg.Invalid_number:\n                lexical_errors_file.write(\n                    \"(\" + token_until_here + \", \" + error_massage + \") \")\n            if error_massage == ErrorMsg.Unclosed_comment:\n                lexical_errors_file.write(\n                    \"(\" + token_until_here[0:7] + \"..., \" + error_massage + \") \")\n            if error_massage == ErrorMsg.Unmatched_comment:\n                lexical_errors_file.write(\n                    \"(\" + token_until_here + \", \" + error_massage + \") \")\n            lexical_errors_file.close()\n        else:\n            lexical_errors_file = open(\"lexical_errors.txt\", \"a\")\n            error_line = line_number\n            if error_massage == ErrorMsg.Invalid_input:\n                lexical_errors_file.write(\n                    \"\\n\" + str(line_number) + \".\" + \"\\t\" + \"(\" + token_until_here + \", \" + error_massage + \") \")\n\n            if error_massage == ErrorMsg.Invalid_number:\n                lexical_errors_file.write(\n                    \"\\n\" + str(line_number) + \".\" + \"\\t\" + \"(\" + token_until_here + \", \" + error_massage + \") \")\n            if error_massage == ErrorMsg.Unclosed_comment:\n                lexical_errors_file.write(\n                    \"\\n\" + str(line_number) + \".\" + \"\\t\" + \"(\" + token_until_here[0:7] + \"..., \" + error_massage + \") \")\n            if error_massage == ErrorMsg.Unmatched_comment:\n                lexical_errors_file.write(\n                    \"\\n\" + str(line_number) + \".\" + \"\\t\" + \"(\" + token_until_here + \", \" + error_massage + \") \")\n            lexical_errors_file.close()\n\n\ndef symbol_table(no, lexeme):  # if symbol is new then add it to the table whit appropriate line number else don't\n    symbol_table_file = open(\"symbol_table.txt\", \"a\")\n    if list_1.count(lexeme) == 0:\n        list_1.append(lexeme)\n        symbol_table_file.write(\"\\n\" + str(no) + \".\\t\" + lexeme)\n        global t\n        t = no + 1\n    symbol_table_file.close()\n\n\ndef initialize():\n    lexical_errors_file1 = open(\"lexical_errors.txt\", \"w+\")\n    lexical_errors_file1.write(\"There is no lexical error.\")\n    lexical_errors_file1.close()\n\n    symbol_table_file1 = open(\"symbol_table.txt\", \"w+\")\n    symbol_table_file1.write(\"1.\\tif\")\n    symbol_table_file1.write(\"\\n2.\\telse\")\n    symbol_table_file1.write(\"\\n3.\\tvoid\")\n    symbol_table_file1.write(\"\\n4.\\tint\")\n    symbol_table_file1.write(\"\\n5.\\twhile\")\n    symbol_table_file1.write(\"\\n6.\\tbreak\")\n    symbol_table_file1.write(\"\\n7.\\tswitch\")\n    symbol_table_file1.write(\"\\n8.\\tdefault\")\n    symbol_table_file1.write(\"\\n9.\\tcase\")\n    symbol_table_file1.write(\"\\n10.\\treturn\")\n    symbol_table_file1.write(\"\\n11.\\tendif\")\n    symbol_table_file1.close()\n\n    tokens_table_file = open(\"tokens1.txt\", \"w+\")\n    tokens_table_file.close()\n\n\ndef printing(to):\n    global current_line\n    if to[0] != \"\":\n        tokens_table_file = open(\"tokens1.txt\", \"r\")\n        content = str(tokens_table_file.read())\n        value = '\\n' + str(to[2])\n        if to[2] != current_line and not value in content:\n            if to[2] == 1:\n                tokens_table_file = open(\"tokens1.txt\", \"a\")\n                tokens_table_file.write(str(to[2]) + \".\" + \"\\t\" + \"(\" + to[0] + \", \" + to[1] + \") \")\n                current_line = current_line + 1\n                tokens_table_file.close()\n            else:\n                tokens_table_file = open(\"tokens1.txt\", \"a\")\n                tokens_table_file.write(\"\\n\" + str(to[2]) + \".\" + \"\\t\" + \"(\" + to[0] + \", \" + to[1] + \") \")\n                current_line = current_line + 1\n                tokens_table_file.close()\n        else:\n            tokens_table_file = open(\"tokens1.txt\", \"a\")\n            tokens_table_file.write(\"(\" + to[0] + \", \" + to[1] + \") \")\n            tokens_table_file.close()\n\n\nif __name__ == '__main__':\n    \" DO not change these lines\"\n    list_1 = [\"if\", \"else\", \"void\", \"int\", \"while\", \"break\", \"switch\", \"default\", \"case\", \"return\", \"endif\"]\n    initialize()\n    cursor_position = 0\n    cursor_line_position = 1\n    \"\"\n    line_read = 1\n    t = 12\n    error_line = 0\n    current_line = 0\n    file = open('input.txt', 'r')\n    program = file.read()\n    index = 0\n\n    \"Call the parser: \"\n    parser_obj = Parser()\n    parser_obj.parser(cursor_line_position, program)\n\n    # for witting in tokens.txt without any empty line at top of the file\n    with open('tokens1.txt', 'r') as infile, open('tokens.txt', 'w') as outfile:\n        for line in infile:\n            if not line.strip(): continue  # skip the empty line\n            outfile.write(line)  # non-empty line. Write it to output\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/compiler.py b/compiler.py
--- a/compiler.py	(revision bb9dd085e67a937e72c1fef8ef8d818423a7c863)
+++ b/compiler.py	(date 1671549326132)
@@ -26,7 +26,7 @@
     # WATCH OUT:  these two massage here not in the documentation format!
     Empty_parse_table = "Empty_parse_table_home"
     Empty_parse_table_goto = "Empty_parse_table_goto_home"
-    # TODO complete error massages in panic mode here base on the documentation
+    # TODO complete error massages in panic mode here base on the documentation...
 
 
 class Parser:
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"AutoImportSettings\">\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\n  </component>\n  <component name=\"ChangeListManager\">\n    <list default=\"true\" id=\"b446052b-eb3f-4e36-b535-52181b0f5e3b\" name=\"Changes\" comment=\"debug parser\" />\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\n  </component>\n  <component name=\"Git.Settings\">\n    <option name=\"RECENT_BRANCH_BY_REPOSITORY\">\n      <map>\n        <entry key=\"$PROJECT_DIR$\" value=\"phase1\" />\n      </map>\n    </option>\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\n  </component>\n  <component name=\"MarkdownSettingsMigration\">\n    <option name=\"stateVersion\" value=\"1\" />\n  </component>\n  <component name=\"ProjectId\" id=\"2HfBOaIlLXTJu6sKq3EjvqslgG1\" />\n  <component name=\"ProjectLevelVcsManager\">\n    <ConfirmationsSetting value=\"2\" id=\"Add\" />\n  </component>\n  <component name=\"ProjectViewState\">\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\n    <option name=\"showLibraryContents\" value=\"true\" />\n  </component>\n  <component name=\"PropertiesComponent\"><![CDATA[{\n  \"keyToString\": {\n    \"ASKED_ADD_EXTERNAL_FILES\": \"true\",\n    \"last_opened_file_path\": \"/home/ubuntu/PycharmProjects/Inferencee\",\n    \"settings.editor.selected.configurable\": \"com.jetbrains.python.configuration.PyActiveSdkModuleConfigurable\"\n  }\n}]]></component>\n  <component name=\"RunManager\">\n    <configuration name=\"compiler\" type=\"PythonConfigurationType\" factoryName=\"Python\" nameIsGenerated=\"true\">\n      <module name=\"compiler_phase1\" />\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\n      <option name=\"PARENT_ENVS\" value=\"true\" />\n      <envs>\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\n      </envs>\n      <option name=\"SDK_HOME\" value=\"$PROJECT_DIR$/../kafkaProducer/venv/bin/python\" />\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" />\n      <option name=\"IS_MODULE_SDK\" value=\"false\" />\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\n      <EXTENSION ID=\"PythonCoverageRunConfigurationExtension\" runner=\"coverage.py\" />\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/compiler.py\" />\n      <option name=\"PARAMETERS\" value=\"\" />\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\n      <option name=\"MODULE_MODE\" value=\"false\" />\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\n      <option name=\"INPUT_FILE\" value=\"\" />\n      <method v=\"2\" />\n    </configuration>\n  </component>\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\n  <component name=\"TaskManager\">\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\n      <changelist id=\"b446052b-eb3f-4e36-b535-52181b0f5e3b\" name=\"Changes\" comment=\"\" />\n      <created>1668666226320</created>\n      <option name=\"number\" value=\"Default\" />\n      <option name=\"presentableId\" value=\"Default\" />\n      <updated>1668666226320</updated>\n      <workItem from=\"1668841336589\" duration=\"1048000\" />\n      <workItem from=\"1668872856867\" duration=\"99000\" />\n      <workItem from=\"1668872967665\" duration=\"1548000\" />\n      <workItem from=\"1669137839545\" duration=\"4000\" />\n      <workItem from=\"1669320961721\" duration=\"24000\" />\n    </task>\n    <task id=\"LOCAL-00001\" summary=\"add scanner code to read char by char from file and recognize the token\">\n      <created>1668672673882</created>\n      <option name=\"number\" value=\"00001\" />\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1668672673882</updated>\n    </task>\n    <task id=\"LOCAL-00002\" summary=\"fix some error in scanner\">\n      <created>1668673329177</created>\n      <option name=\"number\" value=\"00002\" />\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1668673329177</updated>\n    </task>\n    <task id=\"LOCAL-00003\" summary=\"fix some error in scanner\">\n      <created>1668676261730</created>\n      <option name=\"number\" value=\"00003\" />\n      <option name=\"presentableId\" value=\"LOCAL-00003\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1668676261730</updated>\n    </task>\n    <task id=\"LOCAL-00004\" summary=\"fix some error in scanner\">\n      <created>1668676289957</created>\n      <option name=\"number\" value=\"00004\" />\n      <option name=\"presentableId\" value=\"LOCAL-00004\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1668676289957</updated>\n    </task>\n    <task id=\"LOCAL-00005\" summary=\"fix some error in scanner\">\n      <created>1668677743674</created>\n      <option name=\"number\" value=\"00005\" />\n      <option name=\"presentableId\" value=\"LOCAL-00005\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1668677743674</updated>\n    </task>\n    <task id=\"LOCAL-00006\" summary=\"complete finding token and making error table and symbol table\">\n      <created>1668687532046</created>\n      <option name=\"number\" value=\"00006\" />\n      <option name=\"presentableId\" value=\"LOCAL-00006\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1668687532046</updated>\n    </task>\n    <task id=\"LOCAL-00007\" summary=\"debug get token\">\n      <created>1668690286170</created>\n      <option name=\"number\" value=\"00007\" />\n      <option name=\"presentableId\" value=\"LOCAL-00007\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1668690286170</updated>\n    </task>\n    <task id=\"LOCAL-00008\" summary=\"get_next_token and error_massage_table and symbol table are completed.\">\n      <created>1668692833415</created>\n      <option name=\"number\" value=\"00008\" />\n      <option name=\"presentableId\" value=\"LOCAL-00008\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1668692833415</updated>\n    </task>\n    <task id=\"LOCAL-00009\" summary=\"complete version\">\n      <created>1668873067713</created>\n      <option name=\"number\" value=\"00009\" />\n      <option name=\"presentableId\" value=\"LOCAL-00009\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1668873067713</updated>\n    </task>\n    <task id=\"LOCAL-00010\" summary=\"other files\">\n      <created>1668874397737</created>\n      <option name=\"number\" value=\"00010\" />\n      <option name=\"presentableId\" value=\"LOCAL-00010\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1668874397737</updated>\n    </task>\n    <task id=\"LOCAL-00011\" summary=\"resolve error of symbol : after default\">\n      <created>1669363353242</created>\n      <option name=\"number\" value=\"00011\" />\n      <option name=\"presentableId\" value=\"LOCAL-00011\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1669363353242</updated>\n    </task>\n    <task id=\"LOCAL-00012\" summary=\"complete\">\n      <created>1669468479929</created>\n      <option name=\"number\" value=\"00012\" />\n      <option name=\"presentableId\" value=\"LOCAL-00012\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1669468479930</updated>\n    </task>\n    <task id=\"LOCAL-00013\" summary=\"resolve error reorganization of testcase12\">\n      <created>1669470110127</created>\n      <option name=\"number\" value=\"00013\" />\n      <option name=\"presentableId\" value=\"LOCAL-00013\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1669470110127</updated>\n    </task>\n    <task id=\"LOCAL-00014\" summary=\"resolve error line number of lexical error of testcase11\">\n      <created>1669471291481</created>\n      <option name=\"number\" value=\"00014\" />\n      <option name=\"presentableId\" value=\"LOCAL-00014\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1669471291481</updated>\n    </task>\n    <task id=\"LOCAL-00015\" summary=\"resolve error line number of lexical error of testcase11\">\n      <created>1669471468784</created>\n      <option name=\"number\" value=\"00015\" />\n      <option name=\"presentableId\" value=\"LOCAL-00015\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1669471468784</updated>\n    </task>\n    <task id=\"LOCAL-00016\" summary=\"resolve error of space in end of lexical_errors\">\n      <created>1669471824715</created>\n      <option name=\"number\" value=\"00016\" />\n      <option name=\"presentableId\" value=\"LOCAL-00016\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1669471824716</updated>\n    </task>\n    <task id=\"LOCAL-00017\" summary=\"resolve error reorganization\">\n      <created>1669472674481</created>\n      <option name=\"number\" value=\"00017\" />\n      <option name=\"presentableId\" value=\"LOCAL-00017\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1669472674481</updated>\n    </task>\n    <task id=\"LOCAL-00018\" summary=\"resolve error reorganization\">\n      <created>1669472988205</created>\n      <option name=\"number\" value=\"00018\" />\n      <option name=\"presentableId\" value=\"LOCAL-00018\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1669472988205</updated>\n    </task>\n    <task id=\"LOCAL-00019\" summary=\"resolve space\">\n      <created>1669473885176</created>\n      <option name=\"number\" value=\"00019\" />\n      <option name=\"presentableId\" value=\"LOCAL-00019\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1669473885176</updated>\n    </task>\n    <task id=\"LOCAL-00020\" summary=\"phase1\">\n      <created>1670497629132</created>\n      <option name=\"number\" value=\"00020\" />\n      <option name=\"presentableId\" value=\"LOCAL-00020\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1670497629132</updated>\n    </task>\n    <task id=\"LOCAL-00021\" summary=\"write TODO for phase2\">\n      <created>1670499873758</created>\n      <option name=\"number\" value=\"00021\" />\n      <option name=\"presentableId\" value=\"LOCAL-00021\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1670499873758</updated>\n    </task>\n    <task id=\"LOCAL-00022\" summary=\"make by bison table.json\">\n      <created>1671533227560</created>\n      <option name=\"number\" value=\"00022\" />\n      <option name=\"presentableId\" value=\"LOCAL-00022\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1671533227560</updated>\n    </task>\n    <task id=\"LOCAL-00023\" summary=\"make by bison table.json\">\n      <created>1671533418418</created>\n      <option name=\"number\" value=\"00023\" />\n      <option name=\"presentableId\" value=\"LOCAL-00023\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1671533418418</updated>\n    </task>\n    <task id=\"LOCAL-00024\" summary=\"make by bison table.json\">\n      <created>1671533496487</created>\n      <option name=\"number\" value=\"00024\" />\n      <option name=\"presentableId\" value=\"LOCAL-00024\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1671533496487</updated>\n    </task>\n    <task id=\"LOCAL-00025\" summary=\"fill properties from json file\">\n      <created>1671535268989</created>\n      <option name=\"number\" value=\"00025\" />\n      <option name=\"presentableId\" value=\"LOCAL-00025\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1671535268989</updated>\n    </task>\n    <task id=\"LOCAL-00026\" summary=\"add parser code function and read json file\">\n      <created>1671541345538</created>\n      <option name=\"number\" value=\"00026\" />\n      <option name=\"presentableId\" value=\"LOCAL-00026\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1671541345538</updated>\n    </task>\n    <task id=\"LOCAL-00027\" summary=\"add parser code function and read json file\">\n      <created>1671545578822</created>\n      <option name=\"number\" value=\"00027\" />\n      <option name=\"presentableId\" value=\"LOCAL-00027\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1671545578822</updated>\n    </task>\n    <task id=\"LOCAL-00028\" summary=\"debug parser\">\n      <created>1671548780845</created>\n      <option name=\"number\" value=\"00028\" />\n      <option name=\"presentableId\" value=\"LOCAL-00028\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1671548780845</updated>\n    </task>\n    <task id=\"LOCAL-00029\" summary=\"debug parser\">\n      <created>1671548845068</created>\n      <option name=\"number\" value=\"00029\" />\n      <option name=\"presentableId\" value=\"LOCAL-00029\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1671548845068</updated>\n    </task>\n    <option name=\"localTasksCounter\" value=\"30\" />\n    <servers />\n  </component>\n  <component name=\"TypeScriptGeneratedFilesManager\">\n    <option name=\"version\" value=\"3\" />\n  </component>\n  <component name=\"Vcs.Log.Tabs.Properties\">\n    <option name=\"TAB_STATES\">\n      <map>\n        <entry key=\"MAIN\">\n          <value>\n            <State />\n          </value>\n        </entry>\n      </map>\n    </option>\n  </component>\n  <component name=\"VcsManagerConfiguration\">\n    <option name=\"ADD_EXTERNAL_FILES_SILENTLY\" value=\"true\" />\n    <MESSAGE value=\"add scanner code to read char by char from file and recognize the token\" />\n    <MESSAGE value=\"fix some error in scanner\" />\n    <MESSAGE value=\"complete finding token and making error table and symbol table\" />\n    <MESSAGE value=\"debug get token\" />\n    <MESSAGE value=\"get_next_token and error_massage_table and symbol table are completed.\" />\n    <MESSAGE value=\"complete version\" />\n    <MESSAGE value=\"other files\" />\n    <MESSAGE value=\"resolve error of symbol : after default\" />\n    <MESSAGE value=\"complete\" />\n    <MESSAGE value=\"resolve error reorganization of testcase12\" />\n    <MESSAGE value=\"resolve error line number of lexical error of testcase11\" />\n    <MESSAGE value=\"resolve error of space in end of lexical_errors\" />\n    <MESSAGE value=\"resolve error reorganization\" />\n    <MESSAGE value=\"resolve space\" />\n    <MESSAGE value=\"phase1\" />\n    <MESSAGE value=\"write TODO for phase2\" />\n    <MESSAGE value=\"make by bison table.json\" />\n    <MESSAGE value=\"fill properties from json file\" />\n    <MESSAGE value=\"add parser code function and read json file\" />\n    <MESSAGE value=\"debug parser\" />\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"debug parser\" />\n  </component>\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision bb9dd085e67a937e72c1fef8ef8d818423a7c863)
+++ b/.idea/workspace.xml	(date 1671549341200)
@@ -4,7 +4,10 @@
     <option name="autoReloadType" value="SELECTIVE" />
   </component>
   <component name="ChangeListManager">
-    <list default="true" id="b446052b-eb3f-4e36-b535-52181b0f5e3b" name="Changes" comment="debug parser" />
+    <list default="true" id="b446052b-eb3f-4e36-b535-52181b0f5e3b" name="Changes" comment="(debug parser)complete now">
+      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/compiler.py" beforeDir="false" afterPath="$PROJECT_DIR$/compiler.py" afterDir="false" />
+    </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
     <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
@@ -277,7 +280,14 @@
       <option name="project" value="LOCAL" />
       <updated>1671548845068</updated>
     </task>
-    <option name="localTasksCounter" value="30" />
+    <task id="LOCAL-00030" summary="(debug parser)complete now">
+      <created>1671549327611</created>
+      <option name="number" value="00030" />
+      <option name="presentableId" value="LOCAL-00030" />
+      <option name="project" value="LOCAL" />
+      <updated>1671549327611</updated>
+    </task>
+    <option name="localTasksCounter" value="31" />
     <servers />
   </component>
   <component name="TypeScriptGeneratedFilesManager">
@@ -316,6 +326,7 @@
     <MESSAGE value="fill properties from json file" />
     <MESSAGE value="add parser code function and read json file" />
     <MESSAGE value="debug parser" />
-    <option name="LAST_COMMIT_MESSAGE" value="debug parser" />
+    <MESSAGE value="(debug parser)complete now" />
+    <option name="LAST_COMMIT_MESSAGE" value="(debug parser)complete now" />
   </component>
 </project>
\ No newline at end of file
